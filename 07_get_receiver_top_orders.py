# Q. 수평 직선에 탑 N대를 세웠습니다. 모든 탑의 꼭대기에는 신호를 송/수신하는 장치를 설치했습니다.
# 발사한 신호는 신호를 보낸 탑보다 높은 탑에서만 수신합니다.
# 또한 ,한 번 수신된 신호는 다른 탑으로 송신되지 않습니다.

# 예를 들어 높이가 6, 9, 5, 7, 4 인 다섯 탑이 왼쪽으로 동시에 레이저 신호를 발사합니다.
# 그러면, 탑은 다음과 같이 신호를 주고 받습니다.

# 높이가 4인 다섯 번째 탑에서 발사한 신호는 높이가 7인 네 번째 탑에서 수신하고,
# 높이가 7인 네 번째 탑의 신호는 높이가 9인 두 번째 탑이,
# 높이가 5인 세 번째 탑의 신호도 높이가 9인 두 번째 탑이 수신합니다.

# 높이가 9인 두 번째 탑과 높이가 6인 첫 번째 탑이 보낸 레이저 신호는
# 어떤 탑에서도 수신할 수 없습니다.

# 이 때, 맨 왼쪽부터 순서대로 탑의 높이를 담은 배열 heights가 매개변수로 주어질 때
# 각 탑이 쏜 신호를 어느 탑에서 받았는지 기록한 배열을 반환하시오.

top_heights = [6, 9, 5, 7, 4]


# 0으로 초기화된 배열로 시작
# 옆쪽으로 비교하면서 비교가 마친것들은 없애버린다.
# 반복문을통해 비교를할때 : range(시작점 , 끝나는점 , 증감식)

def get_receiver_top_orders(heights):
    answer = [0] * len(heights)  # [0,0,0,0,0]이 생성됨
    while heights:  # 시간복잡도 : O (N^2) # heights가 빈상태가 아닐때까지
        height = heights.pop()

        # [6,9,5,7]로 구성되어있다.
        for idx in range(len(heights) - 1, -1, -1):  # 4(7) 3(5) 2(9) 1(6) 0 을비교해야하기때문에 자기자신을뺌
            if heights[idx] > height:  # 왼쪽 끝값부터 heights[idx]값 비교 ex) 7 > 4
                answer[len(heights)] = idx + 1  # 이전에 4부터 비교를 위해 -1을해줬기 때문에
                # +1을해준다 [0,0,0,0,0]에 들어갈 정답을 구해야하기때문

                # 근데 idx는 [6,9,5,7]로 비교하기때문에 +1을해주는건 ok
                # answer[len(heights)]은 현재 [6,9,5,7]로 이루어져있는데
                # 그럼 이부분이 한칸 증가???

                break  # 비교가 끝났을시에는 더이상 비교를하지 않아도되기때문에 break
    return answer


print(get_receiver_top_orders(top_heights))  # [0, 0, 2, 2, 4] 가 반환되어야 한다!
